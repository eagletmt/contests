---
layout: post
title: "POJ 3139 - Balancing the Scale"
---
[http://poj.org/problem?id=3139](http://poj.org/problem?id=3139)

## 概要
16個の相異なる整数 \\(a\_1 \\cdots a\_16\\) が与えられる。
これをそれぞれ1回ずつ使って

- \\(4 x\_1 + 3 x\_2 + 2 x\_3 + x\_4 = x\_5 + 2 x\_6 + 3 x\_7 + 4 x\_8\\)
- \\(4 y\_1 + 3 y\_2 + 2 y\_3 + y\_4 = y\_5 + 2 y\_6 + 3 y\_7 + 4 y\_8\\)

を満たすような式はいくつあるか答える。

## 制約
- \\(1 \\le a\_i \\le 1024\\)

## 解法
2つの式は同じなので、いわゆる半分全列挙のイメージで、8つの整数の使い方のビットパターン `s` に対して
\\(4 x\_1 + 3 x\_2 + 2 x\_3 + x\_4 = x\_5 + 2 x\_6 + 3 x\_7 + 4 x\_8\\)
を満たすようなものが `x[s]` 通りある、ということがわかれば、
すべてのビットパターン (高々 \\(2 ^ {16}\\) 通りしかない) について `x[s] * x[s の反転]` の総和をとれば答えになる。

しかし、8つの整数の使い方は単純に列挙すると \\(16 \\cdot 15 \\cdots 9 = 518918400\\) 通りもあるので厳しい。
そこで式の両辺が対称的であり、制約から各辺の和が高々 10240 しかないことから、

    v[val] = 16個の整数から4つ選んで並べたときの和が val になるようなビットパターンの配列

というのを計算し、各 `v[val]` から2つ選んだもののうち、ビットパターンが重なっていないものが求める8つの整数の選び方である、というように求める。
この方法の計算量はよくわかってない。
10240 のループの中に二重ループがあるけどそんなに回らない、つまりそんなに総和は被らないんじゃないかと思う。

{% include_code lang:cpp poj/3139.cc %}
