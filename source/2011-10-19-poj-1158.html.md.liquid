---
layout: post
title: "POJ 1158 - TRAFFIC LIGHTS"
---
[http://poj.org/problem?id=1158](http://poj.org/problem?id=1158)

## 概要
N 個のジャンクションを M 本の道が結んでいる．
道は双方向に進むことができる．
ジャンクション i, j を結ぶ道は長さ l[i][j] であり，単位長さの道を進むのに単位時間掛かる．

各ジャンクションには青色と紫色からなる信号機があり，i 番目のジャンクションの信号機は青色の期間が t[i][B]，紫色の期間が t[i][P] である．
また，初期状態での色が与えられ，その色である期間は r[i] である．

今いるジャンクションの信号機の色と，道を通った先のジャンクションのそれが，今いるジャンクションから出発する瞬間に一致しているときのみ進むことができる．
ただし，あるジャンクションに到達した瞬間に信号機の色が変わった場合，そのジャンクションからまた別のジャンクションに出発できるかどうかは，変わった後の色で判断する．

出発するジャンクションと目的地のジャンクションが与えられるので，目的地に辿りつくまでの最小の時間を答える．
辿りつけない場合は 0 を答える．

## 制約
- グラフは連結 (at most one road between any two different junctions)
- 自分自身へのエッジは無い (no road connecting a junction to itself)
- 2 <= N <= 300
- 1 <= M <= 14000
- 1 <= l[i][j] <= 100
- 1 <= t[i][c] <= 100
- 1 <= r[i] <= 100

## 解法
ダイクストラ．しかし何秒待ってから次のノードに行けるかの計算がやや面倒．

ある信号が現在時刻 t 以降で最初に色が変わる時間を返す `next_tick` を書き，今いるノードと次のノードでそれぞれの `next_tick` 毎に時間を進めて色が一致するまでループするような実装にした．

ただし，全く同じタイミングで逆の色に変わり続けるとループが止まらなくなってしまう．
このケースを忘れて最初 TLE してしまった．
問題文で連結と言っておきながら目的地に到達できないケースについて言及していたんだし，普通に気付くべき．

いつか次のノードに行けるとしたら最大で 3 回しかループし得ないので，それ以上やってもダメだったら行けないと判断するようにした．

{% include_code lang:cpp poj/1158.cc %}
