---
layout: post
title: "POJ 3523 - The Morning after Halloween"
---
[http://poj.org/problem?id=3523](http://poj.org/problem?id=3523)

## 概要
w \* h のグリッド上に n 体のロボットの初期位置とそれぞれのゴール地点が与えられる．

1ステップで，同時に各ロボットを4方向に移動させるか全く移動させないという操作ができる．
ただし，壁のあるマスへは進めず，また1ステップで2体のロボットの位置をスワップさせるこはできない．

すべてのロボットをゴール地点へ移動させるのに必要な最小のステップ数を答える．

## 制約
-  1 <= n <= 3
- 4 <= w, h <= 16
- グリッドの周囲は壁で囲まれている
- 任意の 2x2 の領域に少なくとも1マス壁がある

## 解法
状態数は最大で 256^3 で，壁に囲まれていることや4つ目の制約から実際にはそんなに状態数は無いので，単に BFS してもがんばって定数倍最適化すれば本番のデータセットに対して1分ちょっとで解ける．

しかしこれではオンラインジャッジでは通らないので，A\* で解く．
このときヒューリスティクスに使うゴールまでの推定距離関数 h には，
各ロボットの位置からそのロボットのゴールまでの距離の最大値を使った．
この距離は最初に3回 BFS しておけば求まる．

また，余計な探索候補を入れないようにするために各状態へのステップ数を覚えておきたい．
これを `int dist[256*256*256]` で持つと MLE．
`short dist[256*256*256]` でも AOJ だと MLE するので `unsigned char dist[256*256*256]` で持った．
しかしこれだとオーバーフローする可能性があるので，オーバーフローしたときは `map<int,short>` に切り替えるようにして MLE を回避した．

以下のコードは POJ 3523 で 3266MS，AOJ 1281 で 1:94 で通ったもの．

{% include_code lang:cpp poj/3523.cc %}
